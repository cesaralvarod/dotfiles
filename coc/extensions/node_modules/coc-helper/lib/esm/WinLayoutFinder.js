import { workspace } from 'coc.nvim';
export class WinLayoutFinder {
    constructor(root) {
        this.root = root;
    }
    static convertVimLayoutNode(vimLayout, parent) {
        if (vimLayout[0] === 'leaf') {
            return {
                type: vimLayout[0],
                winid: vimLayout[1],
                parent,
            };
        }
        else {
            const group = {
                type: vimLayout[0],
                children: [],
            };
            group.children = vimLayout[1].map((child, idx) => this.convertVimLayoutNode(child, {
                group,
                indexInParent: idx,
            }));
            return group;
        }
    }
    static async create() {
        const root = await workspace.nvim.call('winlayout', []);
        return new this(this.convertVimLayoutNode(root));
    }
    static getFirstLeafWinid(node) {
        if (node.type === 'leaf') {
            return node.winid;
        }
        else {
            return this.getFirstLeafWinid(node.children[0]);
        }
    }
    /**
     * @return [node, parent, indexInParent]
     */
    findWinid(winid, beginNode = this.root) {
        if (beginNode.type === 'leaf') {
            if (beginNode.winid === winid) {
                return beginNode;
            }
            else {
                return;
            }
        }
        else {
            for (const child of beginNode.children) {
                const target = this.findWinid(winid, child);
                if (target) {
                    return target;
                }
            }
            return;
        }
    }
    findClosest(beginNode, matchWinids) {
        const checked = new Set([beginNode]);
        const queue = [beginNode];
        while (queue.length) {
            const node = queue.shift();
            if (node.type === 'leaf') {
                if (matchWinids.includes(node.winid)) {
                    return node;
                }
            }
            else {
                for (const child of node.children) {
                    if (!checked.has(child)) {
                        queue.push(child);
                        checked.add(child);
                        continue;
                    }
                }
            }
            if (node.parent && !checked.has(node.parent.group)) {
                queue.push(node.parent.group);
                checked.add(node.parent.group);
            }
        }
    }
}
