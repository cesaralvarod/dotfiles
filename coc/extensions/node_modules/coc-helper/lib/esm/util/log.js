import { window } from 'coc.nvim';
import util from 'util';
import { isTest } from './env';
const levelList = [
    'trace',
    'debug',
    'info',
    'warn',
    'error',
    'fatal',
    'off',
];
const levelErrorNum = levelList.indexOf('error');
function formatDate(date) {
    return `${date.toLocaleString()} ${date
        .getMilliseconds()
        .toString()
        .padStart(3, '0')}`;
}
export class HelperLogger {
    constructor(channelName) {
        this.channelName = channelName;
        this.timeMarkers = new Map();
        this.levelStatus = 'trace';
        this.levelNumber = levelList.indexOf(this.levelStatus);
        this.appendLine = this.appendLine.bind(this);
        this.log = this.log.bind(this);
        this.trace = this.trace.bind(this);
        this.debug = this.debug.bind(this);
        this.info = this.info.bind(this);
        this.warn = this.warn.bind(this);
        this.error = this.error.bind(this);
        this.fatal = this.fatal.bind(this);
    }
    /**
     * Default level is 'trace'
     */
    set level(level) {
        this.levelStatus = level;
        this.levelNumber = levelList[level];
    }
    get level() {
        return this.levelStatus;
    }
    dispose() {
        var _a;
        (_a = this.outputChannel_) === null || _a === void 0 ? void 0 : _a.dispose();
    }
    get outputChannel() {
        if (!this.outputChannel_) {
            this.outputChannel_ = window.createOutputChannel(this.channelName);
        }
        return this.outputChannel_;
    }
    appendLine(line) {
        this.outputChannel.appendLine(line);
    }
    log(levelName, data) {
        var _a, _b;
        const levelNum = levelList[levelName];
        if (levelNum < this.levelNumber) {
            return;
        }
        const prefix = `[${formatDate(new Date())}] [${levelName}]: `;
        if (data instanceof Error) {
            this.appendLine(`${prefix}${(_a = data.stack) !== null && _a !== void 0 ? _a : data.toString()}`);
            // eslint-disable-next-line no-restricted-properties
            window.showMessage(data.message, 'error');
            // this.outputChannel?.appendLine(data.stack ?? data.toString());
            if (isTest) {
                // eslint-disable-next-line no-console
                console.error((_b = data.stack) !== null && _b !== void 0 ? _b : data.toString());
            }
            return;
        }
        this.appendLine(`${prefix}${data}`);
        if (levelNum > levelErrorNum) {
            // eslint-disable-next-line no-restricted-properties
            window.showMessage(data, 'error');
            if (isTest) {
                // eslint-disable-next-line no-console
                console.error(data);
            }
        }
    }
    trace(line) {
        this.log('trace', line);
    }
    debug(line) {
        this.log('debug', line);
    }
    info(line) {
        this.log('info', line);
    }
    warn(line) {
        this.log('warn', line);
    }
    /**
     * Log and print error
     */
    error(data) {
        if (!(data instanceof Error)) {
            data = new Error(data);
        }
        this.log('error', data);
    }
    fatal(data) {
        this.log('fatal', data);
    }
    time(label = 'default') {
        this.timeMarkers.set(label, new Date().valueOf());
    }
    /**
     * @returns milliseconds
     */
    timeElapsed(label = 'default') {
        const time = this.timeMarkers.get(label);
        if (time !== undefined) {
            return new Date().valueOf() - time;
        }
    }
    timeLog(label = 'default') {
        const time = this.timeElapsed(label);
        if (time !== undefined) {
            this.appendLine(`${label}: ${time} ms`);
        }
    }
    measureTime(task) {
        const time = new Date().valueOf();
        const result = task();
        if (!('then' in result)) {
            return [result, new Date().valueOf() - time];
        }
        return result.then((r) => {
            return [r, new Date().valueOf() - time];
        });
    }
    measureTask(task, label = 'default', level = 'info') {
        const response = this.measureTime(task);
        if (!('then' in response)) {
            const [result, time] = response;
            this.log(level, `[measureTask] ${label}: ${time} ms`);
            return result;
        }
        return response.then(([result, time]) => {
            this.log(level, `${label}: ${time} ms`);
            return result;
        });
    }
    /**
     * Wrap the async function and catch the error
     */
    asyncCatch(fn) {
        return async (...args) => {
            try {
                return await fn(...args);
            }
            catch (e) {
                this.error(e);
            }
        };
    }
    prettyPrint(...data) {
        this.info(prettyObject(...data));
        // eslint-disable-next-line no-restricted-properties
        window.showMessage(`[${formatDate(new Date())}] ${prettyObject(...data)}`);
    }
}
export const helperLogger = new HelperLogger('coc-helper');
export function prettyObject(...data) {
    return data.map((d) => util.inspect(d)).join(' ');
}
export function prettyPrint(...data) {
    helperLogger.prettyPrint(...data);
}
