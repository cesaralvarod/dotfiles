/*---------------------------------------------------------------------------------------------
 * Licensed under the MIT License. See LICENSE in the project root for license information.
 *
 * 2018-2020 Qiming Zhao <chemzqm@gmail.com>
 * 2020 Weirong Xu <weirongxu.raidou@gmail.com>
 *--------------------------------------------------------------------------------------------*/
/**
 * modified from: https://github.com/neoclide/coc.nvim/blob/5cf5117b9fbbd32d4e4bab2116c36685fee0d881/src/__tests__/helper.ts
 */
import * as cp from 'child_process';
import { EventEmitter } from 'events';
import fs from 'fs';
import os from 'os';
import path from 'path';
import util from 'util';
import { v4 as uuid } from 'uuid';
// @ts-ignore
import attach from 'coc.nvim/attach';
// @ts-ignore
import { terminate } from 'coc.nvim/util/processes';
// @ts-ignore
import completion from 'coc.nvim/completion';
// @ts-ignore
import workspace from 'coc.nvim/workspace';
import { events, } from 'coc.nvim';
// @ts-ignore
global.__TEST__ = true;
const nullChannel = {
    content: '',
    show: () => { },
    dispose: () => { },
    name: 'null',
    append: () => { },
    appendLine: () => { },
    clear: () => { },
    hide: () => { },
};
process.on('uncaughtException', (err) => {
    const msg = `Uncaught exception: ${err.stack}`;
    // eslint-disable-next-line no-console
    console.error(msg);
});
export class JestHelper extends EventEmitter {
    constructor(testsDir) {
        super();
        this.testsDir = testsDir;
        this.setMaxListeners(99);
    }
    set nvim(_nvim) {
        this._nvim = _nvim;
    }
    get nvim() {
        if (!this._nvim) {
            throw new Error('require to execute jestHelper.setup() in beforeAll()');
        }
        return this._nvim;
    }
    set plugin(_plugin) {
        this._plugin = _plugin;
    }
    get plugin() {
        if (!this._plugin) {
            throw new Error('require to execute jestHelper.setup() in beforeAll()');
        }
        return this._plugin;
    }
    boot() {
        beforeAll(async () => {
            try {
                await this.setup();
            }
            catch (e) {
                console.error(e);
            }
        });
        afterAll(async () => {
            await this.shutdown();
        });
        afterEach(async () => {
            await this.reset();
        });
    }
    setupNvim() {
        var _a;
        const vimrc = path.resolve(__dirname, 'vimrc');
        const proc = (this.proc = cp.spawn((_a = process.env.COC_TEST_NVIM) !== null && _a !== void 0 ? _a : 'nvim', ['-u', vimrc, '-i', 'NONE', '--embed'], {
            cwd: __dirname,
        }));
        const plugin = attach({ proc });
        this.nvim = plugin.nvim;
    }
    async setup() {
        const vimrcPath = path.join(this.testsDir, 'vimrc');
        const proc = (this.proc = cp.spawn('nvim', ['-u', vimrcPath, '-i', 'NONE', '--embed'], {
            cwd: this.testsDir,
        }));
        const plugin = (this.plugin = attach({ proc }));
        this.nvim = plugin.nvim;
        this.nvim.uiAttach(160, 80, {}).catch((e) => {
            console.error(e);
        });
        proc.on('exit', () => {
            this.proc = undefined;
        });
        this.nvim.on('notification', (method, args) => {
            if (method === 'redraw') {
                for (const arg of args) {
                    const event = arg[0];
                    this.emit(event, arg.slice(1));
                    if (event == 'put') {
                        const arr = arg.slice(1).map((o) => o[0]);
                        const line = arr.join('').trim();
                        if (line.length > 3) {
                            // console.log(line)
                        }
                    }
                }
            }
        });
        return new Promise((resolve) => {
            plugin.once('ready', resolve);
        });
    }
    async shutdown() {
        if (this.plugin)
            this.plugin.dispose();
        this.nvim.removeAllListeners();
        this._nvim = undefined;
        if (this.proc) {
            this.proc.unref();
            terminate(this.proc);
            this.proc = null;
        }
        await this.wait(60);
    }
    async triggerCompletion(source) {
        await this.nvim.call('coc#start', { source });
    }
    async waitPopup() {
        const visible = await this.nvim.call('pumvisible');
        if (visible)
            return;
        // @ts-ignore
        const res = await events.race(['MenuPopupChanged'], 2000);
        if (!res)
            throw new Error('wait pum timeout after 2s');
    }
    async waitPreviewWindow() {
        for (let i = 0; i < 40; i++) {
            await this.wait(50);
            const has = await this.nvim.call('coc#list#has_preview');
            if (has > 0)
                return;
        }
        throw new Error('timeout after 2s');
    }
    async waitFloat() {
        for (let i = 0; i < 50; i++) {
            await this.wait(20);
            const winid = await this.nvim.call('GetFloatWin');
            if (winid)
                return winid;
        }
        throw new Error('timeout after 2s');
    }
    async selectCompleteItem(idx) {
        await this.nvim.call('nvim_select_popupmenu_item', [idx, true, true, {}]);
    }
    async doAction(method, ...args) {
        return await this.plugin.cocAction(method, ...args);
    }
    async synchronize() {
        const doc = await workspace.document;
        doc.forceSync();
    }
    async reset() {
        const mode = await this.nvim.mode;
        if (mode.blocking && mode.mode == 'r') {
            await this.nvim.input('<cr>');
        }
        else if (mode.mode != 'n' || mode.blocking) {
            await this.nvim.call('feedkeys', [String.fromCharCode(27), 'in']);
        }
        completion.stop();
        workspace.reset();
        await this.nvim.command('silent! %bwipeout!');
        await this.nvim.command('setl nopreviewwindow');
        await this.wait(30);
        await workspace.document;
    }
    async pumvisible() {
        const res = (await this.nvim.call('pumvisible', []));
        return res === 1;
    }
    wait(ms = 30) {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, ms);
        });
    }
    async visible(word, source) {
        await this.waitPopup();
        const context = (await this.nvim.getVar('coc#_context'));
        const items = context.candidates;
        if (!items)
            return false;
        const item = items.find((o) => o.word == word);
        if (!item || !item.user_data)
            return false;
        try {
            const arr = item.user_data.split(':', 2);
            if (source && arr[0] !== source) {
                return false;
            }
        }
        catch (e) {
            return false;
        }
        return true;
    }
    async notVisible(word) {
        const items = await this.getItems();
        return items.findIndex((o) => o.word === word) === -1;
    }
    async getItems() {
        const visible = await this.pumvisible();
        if (!visible) {
            return [];
        }
        const context = (await this.nvim.getVar('coc#_context'));
        const items = context.candidates;
        return items || [];
    }
    async edit(file) {
        if (!file || !path.isAbsolute(file)) {
            file = path.join(__dirname, file ? file : `${uuid()}`);
        }
        const escaped = (await this.nvim.call('fnameescape', file));
        await this.nvim.command(`edit ${escaped}`);
        const doc = await workspace.document;
        return doc.buffer;
    }
    async createDocument(name) {
        const buf = await this.edit(name);
        const doc = workspace.getDocument(buf.id);
        if (!doc) {
            return await workspace.document;
        }
        return doc;
    }
    async listInput(input) {
        // @ts-ignore
        await events.fire('InputChar', ['list', input, 0]);
    }
    async getMarkers(bufnr, ns) {
        return (await this.nvim.call('nvim_buf_get_extmarks', [
            bufnr,
            ns,
            0,
            -1,
            {},
        ]));
    }
    async getCmdline() {
        let str = '';
        for (let i = 1, l = 70; i < l; i++) {
            const ch = await this.nvim.call('screenchar', [79, i]);
            if (ch === -1) {
                break;
            }
            str += String.fromCharCode(ch);
        }
        return str.trim();
    }
    updateConfiguration(key, value) {
        const { configurations } = workspace;
        const curr = workspace.getConfiguration(key);
        configurations.updateUserConfig({ [key]: value });
        return () => {
            configurations.updateUserConfig({ [key]: curr });
        };
    }
    async mockFunction(name, result) {
        const content = `
    function! ${name}(...)
      return ${typeof result == 'number' ? result : JSON.stringify(result)}
    endfunction
    `;
        const file = await createTmpFile(content);
        await this.nvim.command(`source ${file}`);
    }
    async items() {
        const context = (await this.nvim.getVar('coc#_context'));
        return context['candidates'] || [];
    }
    async screenLine(line) {
        let res = '';
        for (let i = 1; i <= 80; i++) {
            const ch = await this.nvim.call('screenchar', [line, i]);
            res = res + String.fromCharCode(ch);
        }
        return res;
    }
    async getWinLines(winid) {
        return (await this.nvim.eval(`getbufline(winbufnr(${winid}), 1, '$')`));
    }
    async getFloat() {
        const wins = await this.nvim.windows;
        let floatWin;
        for (const win of wins) {
            const f = await win.getVar('float');
            if (f) {
                floatWin = win;
            }
        }
        return floatWin;
    }
    async getFloats() {
        const ids = await this.nvim.call('coc#float#get_float_win_list', []);
        if (!ids)
            return [];
        return ids.map((id) => this.nvim.createWindow(id));
    }
    async getExtmarkers(bufnr, ns) {
        const res = await this.nvim.call('nvim_buf_get_extmarks', [
            bufnr,
            ns,
            0,
            -1,
            { details: true },
        ]);
        return res.map((o) => {
            return [o[1], o[2], o[3].end_row, o[3].end_col, o[3].hl_group];
        });
    }
    async waitFor(method, args, value) {
        let find = false;
        for (let i = 0; i < 40; i++) {
            await this.wait(50);
            const res = (await this.nvim.call(method, args));
            if (res == value ||
                (value instanceof RegExp && value.test(res.toString()))) {
                find = true;
                break;
            }
        }
        if (!find) {
            throw new Error(`waitFor ${value} timeout`);
        }
    }
    async waitValue(fn, value) {
        let find = false;
        for (let i = 0; i < 40; i++) {
            await this.wait(50);
            const res = fn();
            if (res == value) {
                find = true;
                break;
            }
        }
        if (!find) {
            throw new Error(`waitValue ${value} timeout`);
        }
    }
    createNullChannel() {
        return nullChannel;
    }
}
export function rmdir(dir) {
    if (typeof fs['rm'] === 'function') {
        fs['rmSync'](dir, { recursive: true });
    }
    else {
        fs.rmdirSync(dir, { recursive: true });
    }
}
export async function createTmpFile(content) {
    const tmpFolder = path.join(os.tmpdir(), `coc-${process.pid}`);
    if (!fs.existsSync(tmpFolder)) {
        fs.mkdirSync(tmpFolder);
    }
    const fsPath = path.join(tmpFolder, uuid());
    await util.promisify(fs.writeFile)(fsPath, content, 'utf8');
    return fsPath;
}
export const jestHelper = new JestHelper(path.join(__dirname, '../../tests'));
