import { Disposable, ExtensionContext } from 'coc.nvim';
import { HelperLogger } from './util';
import { VimModule } from './VimModule';
declare type Arguments<F extends Function> = F extends (...args: infer Args) => any ? Args : never;
declare namespace HelperEventEmitter {
    type EventResult = void | Promise<void>;
    type EventListener = (...args: any[]) => EventResult;
    type BufEventListener = (bufnr: number) => EventResult;
    interface VimEventOptions {
        eventExpr: string;
        argExprs?: string[];
        /**
         * @default
         */
        async?: boolean;
    }
}
export declare class HelperEventEmitter<Events extends Record<string, any>> {
    protected helperLogger: HelperLogger;
    readonly concurrent: boolean;
    listenersMap: Map<keyof Events, HelperEventEmitter.EventListener[]>;
    constructor(helperLogger: HelperLogger, concurrent?: boolean);
    listeners(event: keyof Events): HelperEventEmitter.EventListener[];
    once<E extends keyof Events>(event: E, listener: Events[E], disposables?: Disposable[]): Disposable;
    on<E extends keyof Events>(event: E, listener: Events[E], disposables?: Disposable[]): Disposable;
    off<E extends keyof Events>(event: E, listener: Events[E]): void;
    fire<E extends keyof Events>(event: E, ...args: Arguments<Events[E]>): Promise<void>;
}
/**
 * Support more vim events
 *
 * @example
 * ```typescript
 * export const helperVimEvents = new HelperVimEvents<{
 *   BufDelete: HelperEventEmitter.BufEventListener;
 *   BufWipeout: HelperEventEmitter.BufEventListener;
 * }>(
 *   {
 *     BufDelete: {
 *       eventExpr: 'BufDelete *',
 *       argExprs: ["+expand('<abuf>')"],
 *     },
 *     CocDiagnosticChange: {
 *       eventExpr: 'User CocDiagnosticChange',
 *     },
 *   },
 *   (error: Error | string) => void,
 * );
 * ```
 */
export declare class HelperVimEvents<VimEvents extends Record<string, HelperEventEmitter.EventListener>> {
    protected vimEvents: Record<keyof VimEvents, HelperEventEmitter.VimEventOptions>;
    protected helperLogger: HelperLogger;
    protected options: {
        name?: string;
        /**
         * @default false
         */
        concurrent?: boolean;
    };
    readonly events: HelperEventEmitter<VimEvents>;
    readonly augroupName: string;
    readonly commandName: string;
    readonly id: number;
    constructor(vimEvents: Record<keyof VimEvents, HelperEventEmitter.VimEventOptions>, helperLogger: HelperLogger, options?: {
        name?: string;
        /**
         * @default false
         */
        concurrent?: boolean;
    });
    register(context: ExtensionContext): Promise<void>;
}
export declare const helperVimEvents: HelperVimEvents<{
    BufDelete: HelperEventEmitter.BufEventListener;
    BufWipeout: HelperEventEmitter.BufEventListener;
}>;
export declare const helperEvents: HelperEventEmitter<{
    BufDelete: HelperEventEmitter.BufEventListener;
    BufWipeout: HelperEventEmitter.BufEventListener;
}>;
export declare namespace eventsModule {
    interface ActivateEvent extends HelperEventEmitter.VimEventOptions {
        event: string;
    }
}
export declare const eventsModule: {
    activate: {
        call: (augroupName: string, commandName: string, activateEvents: eventsModule.ActivateEvent[]) => Promise<void>;
        callNotify: (augroupName: string, commandName: string, activateEvents: eventsModule.ActivateEvent[]) => void;
        callNotifier: (augroupName: string, commandName: string, activateEvents: eventsModule.ActivateEvent[]) => import("./notifier").Notifier;
    };
    deactivate: VimModule.FnCaller<[augroupName: string], void>;
    doAutocmd: VimModule.FnCaller<[name: string], void>;
};
export {};
