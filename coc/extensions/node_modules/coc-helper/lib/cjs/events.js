"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.eventsModule = exports.helperEvents = exports.helperVimEvents = exports.HelperVimEvents = exports.HelperEventEmitter = void 0;
const coc_nvim_1 = require("coc.nvim");
const util_1 = require("./modules/util");
const util_2 = require("./util");
const module_1 = require("./util/module");
const VimModule_1 = require("./VimModule");
const mid = (0, module_1.getModuleId)('events');
const uname = `m${mid}_v${util_2.versionName}`;
class HelperEventEmitter {
    constructor(helperLogger, concurrent = false) {
        this.helperLogger = helperLogger;
        this.concurrent = concurrent;
        this.listenersMap = new Map();
    }
    listeners(event) {
        if (!this.listenersMap.has(event)) {
            const listeners = [];
            this.listenersMap.set(event, listeners);
            return listeners;
        }
        return this.listenersMap.get(event);
    }
    once(event, listener, disposables) {
        this.listeners(event).push(async (...args) => {
            const result = await listener(...args);
            disposable.dispose();
            return result;
        });
        const disposable = coc_nvim_1.Disposable.create(() => this.off(event, listener));
        if (disposables) {
            disposables.push(disposable);
        }
        return disposable;
    }
    on(event, listener, disposables) {
        this.listeners(event).push(listener);
        const disposable = coc_nvim_1.Disposable.create(() => this.off(event, listener));
        if (disposables) {
            disposables.push(disposable);
        }
        return disposable;
    }
    off(event, listener) {
        // @ts-ignore
        if (typeof listener.cancel === 'function') {
            // @ts-ignore
            listener.cancel();
        }
        const listeners = this.listeners(event);
        const index = listeners.indexOf(listener);
        if (index !== -1) {
            listeners.splice(index, 1);
        }
    }
    async fire(event, ...args) {
        if (this.concurrent) {
            await Promise.all(this.listeners(event).map(async (listener) => {
                try {
                    await listener(...args);
                }
                catch (e) {
                    this.helperLogger.error(e);
                }
            }));
        }
        else {
            for (const listener of this.listeners(event)) {
                try {
                    await listener(...args);
                }
                catch (e) {
                    this.helperLogger.error(e);
                }
            }
        }
    }
}
exports.HelperEventEmitter = HelperEventEmitter;
/**
 * Support more vim events
 *
 * @example
 * ```typescript
 * export const helperVimEvents = new HelperVimEvents<{
 *   BufDelete: HelperEventEmitter.BufEventListener;
 *   BufWipeout: HelperEventEmitter.BufEventListener;
 * }>(
 *   {
 *     BufDelete: {
 *       eventExpr: 'BufDelete *',
 *       argExprs: ["+expand('<abuf>')"],
 *     },
 *     CocDiagnosticChange: {
 *       eventExpr: 'User CocDiagnosticChange',
 *     },
 *   },
 *   (error: Error | string) => void,
 * );
 * ```
 */
class HelperVimEvents {
    constructor(vimEvents, helperLogger, options = {}) {
        var _a;
        this.vimEvents = vimEvents;
        this.helperLogger = helperLogger;
        this.options = options;
        this.id = (0, module_1.getModuleId)('events.id');
        this.augroupName = `CocHelperInternal_${uname}_${options.name ? `${options.name}_` : ''}${this.id}`;
        this.commandName = `coc-helper.internal.didVimEvent_${uname}_${options.name ? `${options.name}_` : ''}${this.id}`;
        this.events = new HelperEventEmitter(this.helperLogger, (_a = options.concurrent) !== null && _a !== void 0 ? _a : false);
    }
    async register(context) {
        await exports.eventsModule.activate.call(this.augroupName, this.commandName, Object.entries(this.vimEvents).map(([key, e]) => (Object.assign({ event: key }, e))));
        context.subscriptions.push(coc_nvim_1.Disposable.create(async () => {
            await exports.eventsModule.deactivate.call(this.augroupName);
        }));
        context.subscriptions.push(coc_nvim_1.commands.registerCommand(this.commandName, util_2.helperLogger.asyncCatch((event, ...args) => this.events.fire(event, ...args)), undefined, true));
    }
}
exports.HelperVimEvents = HelperVimEvents;
exports.helperVimEvents = new HelperVimEvents({
    BufDelete: {
        eventExpr: 'BufDelete *',
        argExprs: ["+expand('<abuf>')"],
    },
    BufWipeout: {
        eventExpr: 'BufWipeout *',
        argExprs: ["+expand('<abuf>')"],
    },
}, util_2.helperLogger, {
    name: 'coc_helper',
});
exports.helperEvents = exports.helperVimEvents.events;
exports.eventsModule = VimModule_1.VimModule.create('events', (m) => {
    const activate = m.fn('activate', ({ name }) => `
      function! ${name}(augroup_name, autocmd_events) abort
        execute 'augroup ' . a:augroup_name
          autocmd!
          for autocmd_event in a:autocmd_events
            execute autocmd_event
          endfor
        augroup END
      endfunction
    `);
    function getActivateEvents(commandName, activateEvents) {
        return activateEvents.map((e) => {
            var _a;
            const args = `${[
                `'${commandName}'`,
                `'${e.event}'`,
                ...((_a = e.argExprs) !== null && _a !== void 0 ? _a : []),
            ].join(', ')}`;
            return `autocmd ${e.eventExpr} call ${e.async === false
                ? util_1.utilModule.runCocCmd.inlineCall(args)
                : util_1.utilModule.runCocCmdAsync.inlineCall(args)}`;
        });
    }
    return {
        activate: {
            call: (augroupName, commandName, activateEvents) => activate.call(augroupName, getActivateEvents(commandName, activateEvents)),
            callNotify: (augroupName, commandName, activateEvents) => activate.callNotify(augroupName, getActivateEvents(commandName, activateEvents)),
            callNotifier: (augroupName, commandName, activateEvents) => activate.callNotifier(augroupName, getActivateEvents(commandName, activateEvents)),
        },
        deactivate: m.fn('deactivate', ({ name }) => `
        function! ${name}(augroup_name) abort
          execute 'augroup ' . a:augroup_name
            autocmd!
          augroup END
        endfunction
      `),
        doAutocmd: m.fn('do_autocmd', ({ name }) => `
        function! ${name}(name) abort
          if exists('#User#'.a:name)
            exe 'doautocmd <nomodeline> User '.a:name
          endif
        endfunction
      `),
    };
});
