"use strict";
/*---------------------------------------------------------------------------------------------
 * Licensed under the MIT License. See LICENSE in the project root for license information.
 *
 * 2018-2020 Qiming Zhao <chemzqm@gmail.com>
 * 2020 Weirong Xu <weirongxu.raidou@gmail.com>
 *--------------------------------------------------------------------------------------------*/
/**
 * modified from: https://github.com/neoclide/coc.nvim/blob/f40fdf889f65412d763cf43995f707b4b461e9f2/src/__tests__/helper.ts
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.jestHelper = exports.JestHelper = void 0;
const cp = __importStar(require("child_process"));
const events_1 = require("events");
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const util_1 = __importDefault(require("util"));
const uuid_1 = require("uuid");
// @ts-ignore
const attach_1 = __importDefault(require("coc.nvim/lib/attach"));
const coc_nvim_1 = require("coc.nvim");
// @ts-ignore
global.__TEST__ = true;
process.on('uncaughtException', (err) => {
    const msg = 'Uncaught exception: ' + err.stack;
    // eslint-disable-next-line no-console
    console.error(msg);
});
class JestHelper extends events_1.EventEmitter {
    constructor(testsDir) {
        super();
        this.testsDir = testsDir;
        this.setMaxListeners(99);
    }
    set nvim(_nvim) {
        this._nvim = _nvim;
    }
    get nvim() {
        if (!this._nvim) {
            throw new Error('require to execute jestHelper.setup() in beforeAll()');
        }
        return this._nvim;
    }
    set plugin(_plugin) {
        this._plugin = _plugin;
    }
    get plugin() {
        if (!this._plugin) {
            throw new Error('require to execute jestHelper.setup() in beforeAll()');
        }
        return this._plugin;
    }
    boot() {
        beforeAll(async () => {
            await this.setup();
        });
        afterAll(async () => {
            await this.shutdown();
        });
        afterEach(async () => {
            await this.reset();
        });
    }
    async setup() {
        const vimrcPath = path_1.default.join(this.testsDir, 'vimrc');
        const proc = (this.proc = cp.spawn('nvim', ['-u', vimrcPath, '-i', 'NONE', '--embed'], {
            cwd: this.testsDir,
        }));
        const plugin = (this.plugin = (0, attach_1.default)({ proc }));
        this.nvim = plugin.nvim;
        this.nvim.uiAttach(160, 80, {}).catch((_e) => {
            // noop
        });
        proc.on('exit', () => {
            this.proc = undefined;
        });
        this.nvim.on('notification', (method, args) => {
            if (method === 'redraw') {
                for (const arg of args) {
                    const event = arg[0];
                    this.emit(event, arg.slice(1));
                }
            }
        });
        return new Promise((resolve) => {
            plugin.once('ready', resolve);
        });
    }
    async shutdown() {
        this.plugin.dispose();
        await this.nvim.quit();
        if (this.proc) {
            this.proc.kill('SIGKILL');
        }
        await this.wait(60);
    }
    async waitPopup() {
        for (let i = 0; i < 40; i++) {
            await this.wait(50);
            const visible = await this.nvim.call('pumvisible');
            if (visible) {
                return;
            }
        }
        throw new Error('timeout after 2s');
    }
    async waitFloat() {
        for (let i = 0; i < 40; i++) {
            await this.wait(50);
            const winid = await this.nvim.call('coc#util#get_float');
            if (winid) {
                return winid;
            }
        }
        throw new Error('timeout after 2s');
    }
    async selectCompleteItem(idx) {
        await this.nvim.call('nvim_select_popupmenu_item', [idx, true, true, {}]);
    }
    async reset() {
        const mode = await this.nvim.call('mode');
        if (mode !== 'n') {
            await this.nvim.command('stopinsert');
            await this.nvim.call('feedkeys', [String.fromCharCode(27), 'in']);
        }
        await this.nvim.command('silent! %bwipeout!');
        await this.wait(60);
    }
    async pumvisible() {
        const res = (await this.nvim.call('pumvisible', []));
        return res === 1;
    }
    wait(ms = 30) {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, ms);
        });
    }
    async visible(word, source) {
        await this.waitPopup();
        const context = (await this.nvim.getVar('coc#_context'));
        const items = context.candidates;
        if (!items) {
            return false;
        }
        const item = items.find((o) => o.word === word);
        if (!item || !item.user_data) {
            return false;
        }
        try {
            const o = JSON.parse(item.user_data);
            if (source && o.source !== source) {
                return false;
            }
        }
        catch (e) {
            return false;
        }
        return true;
    }
    async notVisible(word) {
        const items = await this.getItems();
        return items.findIndex((o) => o.word === word) === -1;
    }
    async getItems() {
        const visible = await this.pumvisible();
        if (!visible) {
            return [];
        }
        const context = (await this.nvim.getVar('coc#_context'));
        const items = context.candidates;
        return items || [];
    }
    async edit(file) {
        if (!file || !path_1.default.isAbsolute(file)) {
            file = path_1.default.join(__dirname, file ? file : `${(0, uuid_1.v4)()}`);
        }
        const escaped = await this.nvim.call('fnameescape', file);
        await this.nvim.command(`edit ${escaped}`);
        await this.wait(60);
        const bufnr = (await this.nvim.call('bufnr', ['%']));
        return this.nvim.createBuffer(bufnr);
    }
    async createDocument(name) {
        const buf = await this.edit(name);
        const doc = coc_nvim_1.workspace.getDocument(buf.id);
        if (!doc) {
            return await coc_nvim_1.workspace.document;
        }
        return doc;
    }
    async getCmdline() {
        let str = '';
        for (let i = 1, l = 70; i < l; i++) {
            const ch = await this.nvim.call('screenchar', [79, i]);
            if (ch === -1) {
                break;
            }
            str += String.fromCharCode(ch);
        }
        return str.trim();
    }
    updateConfiguration(key, value) {
        const { configurations } = coc_nvim_1.workspace;
        configurations.updateUserConfig({ [key]: value });
    }
    async mockFunction(name, result) {
        const content = `
    function! ${name}(...)
      return ${JSON.stringify(result)}
    endfunction
    `;
        const file = await createTmpFile(content);
        await this.nvim.command(`source ${file}`);
    }
    async items() {
        const context = (await this.nvim.getVar('coc#_context'));
        return context['candidates'] || [];
    }
    async screenLine(line) {
        let res = '';
        for (let i = 1; i <= 80; i++) {
            const ch = await this.nvim.call('screenchar', [line, i]);
            res = res + String.fromCharCode(ch);
        }
        return res;
    }
    async getFloat() {
        const wins = await this.nvim.windows;
        let floatWin;
        for (const win of wins) {
            const f = await win.getVar('float');
            if (f) {
                floatWin = win;
            }
        }
        return floatWin;
    }
}
exports.JestHelper = JestHelper;
async function createTmpFile(content) {
    const tmpFolder = path_1.default.join(os_1.default.tmpdir(), `coc-${process.pid}`);
    if (!fs_1.default.existsSync(tmpFolder)) {
        fs_1.default.mkdirSync(tmpFolder);
    }
    const filename = path_1.default.join(tmpFolder, (0, uuid_1.v4)());
    await util_1.default.promisify(fs_1.default.writeFile)(filename, content, 'utf8');
    return filename;
}
exports.jestHelper = new JestHelper(path_1.default.join(__dirname, '../../tests'));
